priority -50


snippet pr "Pragma LANGUAGE" w
{-# LANGUAGE ${1:Foo} #-}
endsnippet


snippet p$ "Declare pipe version of ($)" w
(&) :: a -> (a -> b) -> b
(&) = flip ($)
infixl 0 &
endsnippet

snippet p. "Declare pipe version of (.)" w
(.>) :: (a -> b) -> (b -> c) -> a -> c
(.>) = flip (.)
infixl 9 .>
endsnippet

snippet p "Declare pipe version of ($) and (.) both" w
(&) :: a -> (a -> b) -> b
(&) = flip ($)
infixl 0 &

(.>) :: (a -> b) -> (b -> c) -> a -> c
(.>) = flip (.)
infixl 9 .>
endsnippet


snippet u "undefined" w
undefined
endsnippet


snippet i "import" w
import ${1}
endsnippet
snippet pi "import (from explicit package)" w
import "${1:foo}" ${2}
endsnippet

snippet iq "qualified import" w
import qualified ${1}
endsnippet
snippet piq "qualified import (from explicit package)" w
import qualified "${1:foo}" ${2}
endsnippet

snippet is "qualified import as" w
import qualified ${1:Foo} as ${2:Bar}
endsnippet
snippet pis "qualified import as (from explicit package)" w
import qualified "${1:foo}" ${2:Foo} as ${3:Bar}
endsnippet

snippet ix "explicit import" w
import ${1:Foo} (${2:Bar})
endsnippet
snippet pix "explicit import (from explicit package)" w
import "${1:foo}" ${2:Foo} (${3:Bar})
endsnippet


snippet m "module" w
module ${1:Foo} where
endsnippet

snippet mx "module with explicit export" w
module ${1:Foo} (${2:Bar}) where
endsnippet

snippet mm "module with multiline explicit export" w
module ${1:Foo}
	( ${2:Bar}
	) where
endsnippet


# wrapping name of the function to ${} doesn't make sense
# becase we need to edit function name two times, let's
# do it later.
snippet f "declare a function" w
f :: ${1:Foo}
f = ${2:undefined}
endsnippet

snippet l "declare a lambda" i
\\${1:x} -> ${2:undefined}
endsnippet

snippet lb "declare a lambda wrapped to brackets" w
(\\${1:x} -> ${2:undefined})
endsnippet


snippet main "main monad" w
main :: IO ()
main = ${1:undefined}
endsnippet
