priority -50
extends surround-hacks

snippet f "Anonymous function" w
function (${1}) {
	${2}
}${3}
endsnippet

snippet ff "Arrow function" w
(${1}) => {
	${2}
}${3}
endsnippet

snippet f- "Arrow function (just value)" w
(${1}) => ${2:foo}
endsnippet

snippet fi "Inline anonymous function" w
function (${1}) { ${2} }${3}
endsnippet

snippet fn "Named function" w
function ${1:foo}(${2}) {
	${3}
}${4}
endsnippet

snippet fnn "Named arrow function" w
const ${1:foo} = (${2}) => {
	${3}
};${4}
endsnippet

snippet fn- "Named arrow function (just value)" w
const ${1:foo} = (${2}) => ${3:foo};
endsnippet

snippet fc "Clojure function" i
(function (${2}) {
	${1}
})(${3})${4}
endsnippet

snippet fcc "Clojure arrow function" i
((${2}) => {
	${1}
})(${3})${4}
endsnippet

snippet fc- "Clojure arrow function (just value)" i
((${2}) => ${1})(${3})${4}
endsnippet

snippet if "if condition" i
if (${1}) {
	${2}
}
endsnippet

snippet ife "if/else condition" i
if (${1}) {
	${2}
} else {
	${3}
}
endsnippet

snippet else "else condition continuation" i
else {
	${1}
}
endsnippet

snippet iffe "if/else if/else condition" i
if (${1}) {
	${2}
} else if (${3}) {
	${4}
} else {
	${5}
}
endsnippet

snippet elif "else if condition continuation" i
else if (${1}) {
	${2}
}
endsnippet

snippet elifn "else if inverted condition continuation" i
else if ( ! ${1}) {
	${2}
}
endsnippet

snippet elifn. "else if inverted condition continuation with brackets" i
else if ( ! (${1})) {
	${2}
}
endsnippet

snippet ifn "if inverted condition" i
if ( ! ${1}) {
	${2}
}
endsnippet

snippet ifn. "if inverted condition with brackets" i
if ( ! (${1})) {
	${2}
}
endsnippet

snippet ifne "if/else inverted condition" i
if ( ! ${1}) {
	${2}
} else {
	${3}
}
endsnippet

snippet ifne. "if/else inverted condition with brackets" i
if ( ! (${1})) {
	${2}
} else {
	${3}
}
endsnippet

snippet = "is equal" w
=== ${1}
endsnippet
snippet / "not equal" w
!== ${1}
endsnippet

snippet -o "Simple key-value object" i
{ ${1}: ${2} }${3}
endsnippet

snippet .e "List each method" i
.forEach(function (${1:item}) {
	${2}
})${3}
endsnippet
snippet .ee "List each method (arrow function)" i
.forEach(${1:item} => {
	${2}
})${3}
endsnippet
snippet .e- "List each method (arrow function, just value)" i
.forEach(${1:item} => ${2:item})${3}
endsnippet

snippet .m "List map method" i
.map(function (${1:item}) {
	return ${2:item};
})${3}
endsnippet
snippet .mm "List map method (arrow function)" i
.map(${1:item} => {
	return ${2:item};
})${3}
endsnippet
snippet .m- "List map method (arrow function, just value)" i
.map(${1:item} => ${2:item})${3}
endsnippet

snippet .r "List reduce method" i
.reduce(function (${1:prev}, ${2:next}) {
	return ${3:prev} + ${4:next};
})${5}
endsnippet
snippet .rr "List reduce method (arrow function)" i
.reduce((${1:prev}, ${2:next}) => {
	return ${3:prev} + ${4:next};
})${5}
endsnippet
snippet .r- "List reduce method (arrow function, just value)" i
.reduce((${1:prev}, ${2:next}) => ${3:prev} + ${4:next})${5}
endsnippet

snippet .R "List reduce right method" i
.reduceRight(function (${1:prev}, ${2:next}) {
	return ${3:prev} + ${4:next};
})${5}
endsnippet
snippet .RR "List reduce right method (arrow function)" i
.reduceRight((${1:prev}, ${2:next}) => {
	return ${3:prev} + ${4:next};
})${5}
endsnippet
snippet .R- "List reduce right method (arrow function, just value)" i
.reduceRight((${1:prev}, ${2:next}) => ${3:prev} + ${4:next})${5}
endsnippet

snippet .ro "Reduce to object method" i
.reduce(function (${1:obj}, ${2:item}) {
	${3}
	return ${4:obj};
}, {})${5}
endsnippet
snippet .roo "Reduce to object method (arrow function)" i
.reduce((${1:obj}, ${2:item}) => {
	${3}
	return ${4:obj};
}, {})${5}
endsnippet
snippet .ro- "Reduce to object method (arrow function, just value)" i
.reduce((${1:obj}, ${2:item}) => ${3:obj}, {})${4}
endsnippet

snippet .ra "Reduce to new list method" i
.reduce(function (${1:result}, ${2:item}) {
	return ${3:result}.concat([${4:item}]);
}, ${5:[]})${6}
endsnippet
snippet .raa "Reduce to new list method (arrow function)" i
.reduce((${1:result}, ${2:item}) => {
	return ${3:result}.concat([${4:item}]);
}, ${5:[]})${6}
endsnippet
snippet .ra- "Reduce to new list method (arrow function, just value)" i
.reduce((${1:result}, ${2:item}) => ${3:result}.concat([${4:item}]), ${5:[]})${6}
endsnippet

snippet .rv "List reverse method" i
.reverse()
endsnippet

snippet .sm ".some() list method" i
.some(function (${1:item}) {
	return ${2:item};
})${3}
endsnippet
snippet .smm ".some() list method (arrow function)" i
.some(${1:item} => {
	return ${2:item};
})${3}
endsnippet
snippet .sm- ".some() list method (arrow function, just value)" i
.some(${1:item} => ${2:item})${3}
endsnippet

snippet .ev ".every() list method" i
.every(function (${1:item}) {
	return ${2:item};
})${4}
endsnippet
snippet .evv ".every() list method (arrow function)" i
.every(${1:item} => {
	return ${2:item};
})${4}
endsnippet
snippet .ev- ".every() list method (arrow function, just value)" i
.every(${1:item} => ${2:item})${4}
endsnippet

snippet .fl "List filter method" i
.filter(function (${1:item}) {
	return ${2:item};
})${3}
endsnippet
snippet .fll "List filter method (arrow function)" i
.filter(${1:item} => {
	return ${2:item};
})${3}
endsnippet
snippet .fl- "List filter method (arrow function, just value)" i
.filter(${1:item} => ${2:item})${3}
endsnippet

snippet +. "Push to list method" i
.push(${1})${2}
endsnippet

snippet ++ "List concat method" i
.concat(${1:[]})${2}
endsnippet

snippet .sp "Splice method" i
.splice(${1:0}, ${2:1})${3}
endsnippet

snippet .iof "Index of method" i
.indexOf(${1})${2}
endsnippet


snippet .ts "To string method" i
.toString()
endsnippet

snippet .ca "Char at string method" i
.charAt(${1})${2}
endsnippet

snippet .tlc "Lower case string method" i
.toLowerCase()
endsnippet

snippet .tuc "Upper case string method" i
.toUpperCase()
endsnippet

snippet .t "Trim string method" i
.trim()
endsnippet

snippet .hop "Check for has own property method" i
.hasOwnProperty(${1:foo})${2}
endsnippet


snippet ., "Call method" i
.${1}(${2})${3}
endsnippet

snippet .. "Function delegate method" i
.apply(${1:this}, ${2:arguments})${3}
endsnippet

snippet .= "Function call with context" i
.call(${1:this}${2})${3}
endsnippet

snippet .b "Bind method" i
.bind(${1:this}${2})${3}
endsnippet


snippet ok "Get keys list of hash" i
Object.keys(${1:foo})${2}
endsnippet

snippet oc "Create hash" i
Object.create(${1:null})${2}
endsnippet

snippet ofz "Create expanded frozen hash" i
Object.freeze({
	${1}
})${2}
endsnippet

snippet ofz- "Create frozen hash" i
Object.freeze(${1:\{\}})${2}
endsnippet

snippet oa "Object assign" i
Object.assign(${1:foo}, ${2:bar})${3}
endsnippet

snippet oac "Object clone via assign" i
Object.assign({}, ${1:foo})${2}
endsnippet


snippet isa "Check if it's array" i
Array.isArray(${1})${2}
endsnippet


snippet io "Something is instance of something" i
${1} instanceof ${2:Object}
endsnippet

snippet io- "Something instance of" i
instanceof ${2}
endsnippet


snippet to "setTimeout (async hack)" i
setTimeout(function () {
	${1}
}, ${2:0});${3}
endsnippet
snippet too "setTimeout (async hack) (arrow function)" i
setTimeout(() => {
	${1}
}, ${2:0});${3}
endsnippet
snippet to- "setTimeout (async hack) (arrow function, just value)" i
setTimeout(() => ${1:foo}, ${2:0});${3}
endsnippet

snippet nt "Async call (node.js)" i
process.nextTick(${1:foo});${2}
endsnippet

snippet ntf "Async wrap (node.js)" i
process.nextTick(function () {
	${1}
});${2}
endsnippet
snippet ntff "Async wrap (node.js) (arrow function)" i
process.nextTick(() => {
	${1}
});${2}
endsnippet
snippet ntf- "Async wrap (node.js) (arrow function, just value)" i
process.nextTick(() => ${1:foo});${2}
endsnippet

snippet dn "Current unix-time seconds" i
Date.now()
endsnippet

snippet nd "New instance of Date object" i
new Date()
endsnippet

snippet ne "New exception instance" i
new Error('${1}')${2}
endsnippet

snippet te "Throw new exception instance" i
throw new Error('${1}');${2}
endsnippet

snippet tt "Throw something" i
throw ${1};${2}
endsnippet

snippet tt- "Throw something (without semicolon)" i
throw ${1}
endsnippet



snippet -v "Variable definition with value" i
var ${1:foo} = ${2};${3}
endsnippet

snippet -v- "Variable definition prefix" i
var ${1:foo} = ${2}
endsnippet

snippet -V "var prefix" i
var ${1}
endsnippet


snippet -l "Block scope variable definition with value" i
let ${1:foo} = ${2};${3}
endsnippet

snippet -l- "Block scope variable definition without value" i
let ${1:foo} = ${2}
endsnippet

snippet -L "let prefix" i
let ${1}
endsnippet


snippet -c "Constant definition" i
const ${1:foo} = ${2};${3}
endsnippet

snippet -c- "Constant definition prefix" i
const ${1:foo} = ${2}
endsnippet

snippet -C "const prefix" i
const ${1}
endsnippet



snippet -r "Return value" i
return ${1};
endsnippet

snippet -r- "Return value without semicolon" i
return ${1}
endsnippet

snippet -R "Function break" i
return;
endsnippet

snippet -R- "Function break without semicolon" i
return
endsnippet

snippet tof "Get type of something" i
typeof ${1}
endsnippet

snippet map "Function hash-map with otherwise" i
var map = {
	${2:foo}: function () {
		${3}
	},
	${4:bar}: function () {
		${5}
	},
	otherwise: function () {
		${6}
	}
}, f = map[${1:x}];
f ? f() : map.otherwise();
endsnippet
snippet mapp "Function hash-map with otherwise (arrow function)" i
var map = {
	${2:foo}: () => {
		${3}
	},
	${4:bar}: () => {
		${5}
	},
	otherwise: () => {
		${6}
	}
}, f = map[${1:x}];
f ? f() : map.otherwise();
endsnippet
snippet map- "Function hash-map with otherwise (arrow function, just value)" i
var map = {
	${2:foo}: () => ${3:a},
	${4:bar}: () => ${5:b},
	otherwise: () => ${6:c}
}, f = map[${1:x}];
f ? f() : map.otherwise();
endsnippet
snippet mape "Function hash-map with otherwise (ES6 methods)" i
var map = {
	${2:foo}() {
		${3}
	},
	${4:bar}() {
		${5}
	},
	otherwise() {
		${6}
	}
}, f = map[${1:x}];
f ? f() : map.otherwise();
endsnippet

snippet dg "Call debugger" i
debugger;
endsnippet

snippet cl "console.log" i
console.log(${1});
endsnippet

snippet ci "console.info" i
console.info(${1});
endsnippet

snippet cw "console.warn" i
console.warn(${1});
endsnippet

snippet ce "console.error" i
console.error(${1});
endsnippet

snippet cd "console.debug" i
console.debug(${1});
endsnippet

snippet cg "console.group" i
console.group('${1}');
endsnippet

snippet cge "console.groupEnd" i
console.groupEnd('${1}');
endsnippet

snippet ct "console.time (benchmark)" i
console.time('${1}');
endsnippet

snippet cte "console.timeEnd (benchmark)" i
console.timeEnd('${1}');
endsnippet

snippet cp "console.profile" i
console.profile('${1}');
endsnippet

snippet cpe "console.profileEnd" i
console.profileEnd('${1}');
endsnippet

snippet ca "console.assert" i
console.assert(${1}, '${2}');
endsnippet

snippet !. "Inverted boolean value with brackets" i
 ! (${1})${2}
endsnippet

snippet ! "Inverted boolean value" i
 ! ${1}${2}
endsnippet


snippet :: "Prototype method or property" i
.prototype.
endsnippet

snippet @ "Current context" i
this
endsnippet

snippet @. "Current context method or property" i
this.
endsnippet


snippet .* "Join string" i
.join('${1}')${2}
endsnippet

snippet ./ "Split string" i
.split('${1}')${2}
endsnippet

snippet // "JSDoc comment" i
/**
 * ${1:Description.}
 *
 * @${2:public}
 */
endsnippet

snippet //c "JSDoc inline @const" i
/** @${1:const} */ ${2}
endsnippet

snippet //p "JSDoc inline @private" i
/** @${1:private} */ ${2}
endsnippet

snippet //t "JSDoc inline @type" i
/** @type {${1:Object}} */ ${2}
endsnippet

snippet try "try/catch" i
try {
	${1}
} catch (e) {
	${2}
}
endsnippet
